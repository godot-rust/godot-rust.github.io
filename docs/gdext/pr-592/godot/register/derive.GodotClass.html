<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Derive macro for `GodotClass` on structs."><title>GodotClass in godot::register - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../static.files/rustdoc-5bc39a1768837dd0.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="godot" data-themes="" data-resource-suffix="" data-rustdoc-version="1.77.0-nightly (bf3c6c5be 2024-02-01)" data-channel="nightly" data-search-js="search-dd67cee4cfa65049.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../../static.files/storage-4c98445ec4002617.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../static.files/main-48f368f3872407c8.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-04d5337699b92874.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc derive"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../godot/index.html">godot</a><span class="version">0.1.0</span></h2></div><div class="sidebar-elems"><h2><a href="index.html">In godot::register</a></h2></div></nav><div class="sidebar-resizer"></div>
    <main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><div id="sidebar-button" tabindex="-1"><a href="../../godot/all.html" title="show sidebar"></a></div><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" tabindex="-1"><a href="../../help.html" title="help">?</a></div><div id="settings-menu" tabindex="-1"><a href="../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Derive Macro <a href="../index.html">godot</a>::<wbr><a href="index.html">register</a>::<wbr><a class="derive" href="#">GodotClass</a><button id="copy-path" title="Copy item path to clipboard"><img src="../../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><pre class="rust item-decl"><code>#[derive(GodotClass)]
{
    <span class="comment">// Attributes available to this derive:</span>
    #[class]
    #[base]
    #[hint]
    #[var]
    #[export]
    #[init]
    #[signal]
}
</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Derive macro for <a href="../obj/trait.GodotClass.html"><code>GodotClass</code></a> on structs.</p>
<p>You must use this macro; manual implementations of the <code>GodotClass</code> trait are not supported.</p>
<h2 id="construction"><a class="doc-anchor" href="#construction">§</a>Construction</h2>
<p>To generate a constructor that will let you call <code>MyStruct.new()</code> from GDScript, annotate your
struct with <code>#[class(init)]</code>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[derive(GodotClass)]
#[class(init)]
</span><span class="kw">struct </span>MyStruct {
    <span class="comment">// ...
</span>}</code></pre></div>
<p>The generated <code>init</code> function will initialize each struct field (except the field of type <code>Base&lt;T&gt;</code>, if any)
using <code>Default::default()</code>. To assign some other value, annotate the field with <code>#[init(default = ...)]</code>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[derive(GodotClass)]
#[class(init)]
</span><span class="kw">struct </span>MyStruct {
    <span class="attr">#[init(default = <span class="number">42</span>)]
    </span>my_field: i64
}</code></pre></div>
<p>The given value can be any Rust expression that can be evaluated in the scope where you write
the attribute. However, due to limitations in the parser, some complex expressions must be
surrounded by parentheses. This is the case if the expression includes a <code>,</code> that is <em>not</em>
inside any pair of <code>(...)</code>, <code>[...]</code> or <code>{...}</code> (even if it is, for example, inside <code>&lt;...&gt;</code> or
<code>|...|</code>). A contrived example:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>    <span class="attr">#[init(default = (HashMap::&lt;i64, i64&gt;::new()))]
    </span><span class="comment">//                             ^ parentheses needed due to this comma</span></code></pre></div>
<h2 id="inheritance"><a class="doc-anchor" href="#inheritance">§</a>Inheritance</h2>
<p>Unlike C++, Rust doesn’t really have inheritance, but the GDExtension API lets us “inherit”
from a built-in engine class.</p>
<p>By default, classes created with this library inherit from <code>RefCounted</code>.</p>
<p>To specify a different class to inherit from, add <code>#[class(base = Base)]</code> as an annotation on
your <code>struct</code>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[derive(GodotClass)]
#[class(base = Node2D)]
</span><span class="kw">struct </span>MyStruct {
    <span class="comment">// ...
</span>}</code></pre></div>
<p>If you need a reference to the base class, you can add a field of type <code>Base&lt;T&gt;</code>. The derive macro will pick this up and wire
your object accordingly. You can access it through <code>self.base()</code> and <code>self.base_mut()</code> methods.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[derive(GodotClass)]
#[class(base = Node2D)]
</span><span class="kw">struct </span>MyStruct {
    base: Base&lt;Node2D&gt;,
}</code></pre></div>
<h2 id="properties-and-exports"><a class="doc-anchor" href="#properties-and-exports">§</a>Properties and exports</h2>
<p>In GDScript, there is a distinction between
<a href="https://docs.godotengine.org/en/stable/tutorials/scripting/gdscript/gdscript_basics.html#properties-setters-and-getters">properties</a>
(fields with a <code>get</code> or <code>set</code> declaration) and
<a href="https://docs.godotengine.org/en/stable/tutorials/scripting/gdscript/gdscript_exports.html">exports</a>
(fields annotated with <code>@export</code>). In the GDExtension API, these two concepts are represented with
<code>#[var]</code> and <code>#[export]</code> attributes respectively.</p>
<p>To create a property, you can use the <code>#[var]</code> annotation:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[derive(GodotClass)]
</span><span class="kw">struct </span>MyStruct {
    <span class="attr">#[var]
    </span>my_field: i64,
}</code></pre></div>
<p>This makes the field accessible in GDScript using <code>my_struct.my_field</code> syntax. Additionally, it
generates a trivial getter and setter named <code>get_my_field</code> and <code>set_my_field</code>, respectively.
These are <code>pub</code> in Rust, since they’re exposed from GDScript anyway.</p>
<p>If you want to implement your own getter and/or setter, write those as a function on your Rust
type, expose it using <code>#[func]</code>, and annotate the field with
<code>#[export(get = ..., set = ...)]</code>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[derive(GodotClass)]
</span><span class="kw">struct </span>MyStruct {
    <span class="attr">#[var(get = get_my_field, set = set_my_field)]
    </span>my_field: i64,
}

<span class="attr">#[godot_api]
</span><span class="kw">impl </span>MyStruct {
    <span class="attr">#[func]
    </span><span class="kw">pub fn </span>get_my_field(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; i64 {
        <span class="self">self</span>.my_field
    }

    <span class="attr">#[func]
    </span><span class="kw">pub fn </span>set_my_field(<span class="kw-2">&amp;mut </span><span class="self">self</span>, value: i64) {
        <span class="self">self</span>.my_field = value;
    }
}</code></pre></div>
<p>If you specify only <code>get</code>, no setter is generated, making the field read-only. If you specify
only <code>set</code>, no getter is generated, making the field write-only (rarely useful). To add a
generated getter or setter in these cases anyway, use <code>get</code> or <code>set</code> without a value:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[derive(GodotClass)]
</span><span class="kw">struct </span>MyStruct {
    <span class="comment">// Default getter, custom setter.
    </span><span class="attr">#[var(get, set = set_my_field)]
    </span>my_field: i64,
}

<span class="attr">#[godot_api]
</span><span class="kw">impl </span>MyStruct {
    <span class="attr">#[func]
    </span><span class="kw">pub fn </span>set_my_field(<span class="kw-2">&amp;mut </span><span class="self">self</span>, value: i64) {
        <span class="self">self</span>.my_field = value;
    }
}</code></pre></div>
<p>For exporting properties to the editor, you can use the <code>#[export]</code> attribute:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[derive(GodotClass)]
</span><span class="kw">struct </span>MyStruct {
    <span class="attr">#[export]
    </span>my_field: i64,
}</code></pre></div>
<p>If you dont also include a <code>#[var]</code> attribute, then a default one will be generated.
<code>#[export]</code> also supports all of GDScript’s annotations, in a slightly different format. The format is
translated from an annotation by following these four rules:</p>
<ul>
<li><code>@export</code> becomes <code>#[export]</code></li>
<li><code>@export_{name}</code> becomes <code>#[export(name)]</code></li>
<li><code>@export_{name}(elem1, ...)</code> becomes <code>#[export(name = (elem1, ...))]</code></li>
<li><code>@export_{flags/enum}(&quot;elem1&quot;, &quot;elem2:key2&quot;, ...)</code>
becomes
<code>#[export(flags/enum = (elem1, elem2 = key2, ...))]</code></li>
</ul>
<p>As an example of some different export attributes:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[derive(GodotClass)]
</span><span class="kw">struct </span>MyStruct {
    <span class="comment">// @export
    </span><span class="attr">#[export]
    </span>float: f64,
     
    <span class="comment">// @export_range(0.0, 10.0, or_greater)
    </span><span class="attr">#[export(range = (<span class="number">0.0</span>, <span class="number">10.0</span>, or_greater))]
    </span>range_f64: f64,

    <span class="comment">// @export_file
    </span><span class="attr">#[export(file)]
    </span>file: GString,

    <span class="comment">// @export_file("*.gd")
    </span><span class="attr">#[export(file = <span class="string">"*.gd"</span>)]
    </span>gdscript_file: GString,

    <span class="comment">// @export_flags_3d_physics
    </span><span class="attr">#[export(flags_3d_physics)]
    </span>physics: u32,

    <span class="comment">// @export_exp_easing
    </span><span class="attr">#[export(exp_easing)]
    </span>ease: f64,

    <span class="comment">// @export_enum("One", "Two", "Ten:10", "Twelve:12", "Thirteen")
    </span><span class="attr">#[export(<span class="kw">enum </span>= (One, Two, Ten = <span class="number">10</span>, Twelve = <span class="number">12</span>, Thirteen))]
    </span>exported_enum: i64,

    <span class="comment">// @export_flags("A:1", "B:2", "AB:3")
    </span><span class="attr">#[export(flags = (A = <span class="number">1</span>, B = <span class="number">2</span>, AB = <span class="number">3</span>))]
    </span>flags: u32,
}</code></pre></div>
<p>Most values in expressions like <code>key = value</code>, can be an arbitrary expression that evaluates to the
right value. Meaning you can use constants or variables, as well as any other rust syntax you’d like in
the export attributes.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">const </span>MAX_HEALTH: f64 = <span class="number">100.0</span>;

<span class="attr">#[derive(GodotClass)]
</span><span class="kw">struct </span>MyStruct {
    <span class="attr">#[export(range = (<span class="number">0.0</span>, MAX_HEALTH))]
    </span>health: f64,

    <span class="attr">#[export(flags = (A = <span class="number">0b0001</span>, B = <span class="number">0b0010</span>, C = <span class="number">0b0100</span>, D = <span class="number">0b1000</span>))]
    </span>flags: u32,
}</code></pre></div>
<p>You can specify custom property hints, hint strings, and usage flags in a <code>#[var]</code> attribute using the
<code>hint</code>, <code>hint_string</code>, and <code>usage_flags</code> keys in the attribute:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[derive(GodotClass)]
</span><span class="kw">struct </span>MyStruct {
    <span class="comment">// Treated as an enum with two values: "One" and "Two"
    // Displayed in the editor
    // Treated as read-only by the editor
    </span><span class="attr">#[var(
        hint = PROPERTY_HINT_ENUM,
        hint_string = <span class="string">"One,Two"</span>,
        usage_flags = [PROPERTY_USAGE_EDITOR, PROPERTY_USAGE_READ_ONLY]
    </span>)]
    my_field: i64,
}</code></pre></div>
<h2 id="signals"><a class="doc-anchor" href="#signals">§</a>Signals</h2>
<p>The <code>#[signal]</code> attribute is quite limited at the moment and can only be used for parameter-less signals.
It will be fundamentally reworked.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[derive(GodotClass)]
</span><span class="kw">struct </span>MyClass {}

<span class="attr">#[godot_api]
</span><span class="kw">impl </span>MyClass {
    <span class="attr">#[signal]
    </span><span class="kw">fn </span>some_signal();
}</code></pre></div>
<h2 id="running-code-in-the-editor"><a class="doc-anchor" href="#running-code-in-the-editor">§</a>Running code in the editor</h2>
<p>If you annotate a class with <code>#[class(tool)]</code>, its lifecycle methods (<code>ready()</code>, <code>process()</code> etc.) will be invoked in the editor. This
is useful for writing custom editor plugins, as opposed to classes running simply in-game.</p>
<p>See <a href="../init/trait.ExtensionLibrary.html#method.editor_run_behavior"><code>ExtensionLibrary::editor_run_behavior()</code></a>
for more information and further customization.</p>
<p>This is very similar to <a href="https://docs.godotengine.org/en/stable/tutorials/plugins/running_code_in_the_editor.html">GDScript’s <code>@tool</code> feature</a>.</p>
<h2 id="editor-plugins"><a class="doc-anchor" href="#editor-plugins">§</a>Editor plugins</h2>
<p>If you annotate a class with <code>#[class(editor_plugin)]</code>, it will be turned into an editor plugin. The
class must then inherit from <code>EditorPlugin</code>, and an instance of that class will be automatically added
to the editor when launched.</p>
<p>See <a href="https://docs.godotengine.org/en/stable/tutorials/plugins/editor/index.html">Godot’s documentation of editor plugins</a>
for more information about editor plugins. But note that you do not need to create and enable the plugin
through Godot’s <code>Create New Plugin</code> menu for it to work, simply annotating the class with <code>editor_plugin</code>
automatically enables it when the library is loaded.</p>
<p>This should usually be combined with <code>#[class(tool)]</code> so that the code you write will actually run in the
editor.</p>
<h2 id="class-renaming"><a class="doc-anchor" href="#class-renaming">§</a>Class renaming</h2>
<p>You may want to have structs with the same name. With Rust, this is allowed using <code>mod</code>. However in GDScript,
there are no modules, namespaces, or any such disambiguation.  Therefore, you need to change the names before they
can get to Godot. You can use the <code>rename</code> key while defining your <code>GodotClass</code> for this.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">mod </span>animal {
    <span class="attr">#[derive(GodotClass)]
    #[class(init, rename=AnimalToad)]
    </span><span class="kw">pub struct </span>Toad {}
}

<span class="kw">mod </span>npc {
    <span class="attr">#[derive(GodotClass)]
    #[class(init, rename=NpcToad)]
    </span><span class="kw">pub struct </span>Toad {}
}</code></pre></div>
<p>These classes will appear in the Godot editor and GDScript as “AnimalToad” or “NpcToad”.</p>
<h2 id="hiding-classes"><a class="doc-anchor" href="#hiding-classes">§</a>Hiding classes</h2>
<p>If you want to register a class with Godot, but not have it show up in the editor then you can use <code>#[class(hide)]</code>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[derive(GodotClass)]
#[class(base = Node, init, hide)]
</span><span class="kw">pub struct </span>Foo {}</code></pre></div>
<p>Even though this class is a <code>Node</code> and it has an init function, it still won’t show up in the editor as a node you can add to a scene
because we have added a <code>hide</code> key to the class. This will also prevent it from showing up in documentation.</p>
<h2 id="fine-grained-inference-hints"><a class="doc-anchor" href="#fine-grained-inference-hints">§</a>Fine-grained inference hints</h2>
<p>The derive macro is relatively smart about recognizing <code>Base&lt;T&gt;</code> and <code>OnReady&lt;T&gt;</code> types, and works also if those are qualified.</p>
<p>However, there may be situations where you need to help it out – for example, if you have a type alias for <code>Base&lt;T&gt;</code>, or use an unrelated
<code>my_module::Base&lt;T&gt;</code> with a different meaning.</p>
<p>In this case, you can manually override the behavior with the <code>#[hint]</code> attribute. It takes multiple standalone keys:</p>
<ul>
<li><code>base</code> and <code>no_base</code></li>
<li><code>onready</code> and <code>no_onready</code></li>
</ul>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>godot::engine::Node;

<span class="comment">// There's no reason to do this, but for the sake of example:
</span><span class="kw">type </span>Super&lt;T&gt; = godot::obj::Base&lt;T&gt;;
<span class="kw">type </span>Base&lt;T&gt; = godot::obj::Gd&lt;T&gt;;

<span class="attr">#[derive(godot::register::GodotClass)]
#[class(base = Node)]
</span><span class="kw">struct </span>MyStruct {
   <span class="attr">#[hint(base)]
   </span>base: Super&lt;Node&gt;,

   <span class="attr">#[hint(no_base)]
   </span>unbase: Base&lt;Node&gt;,
}</code></pre></div>
</div></details></section></div></main></body></html>