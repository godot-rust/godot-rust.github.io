<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Derive macro for `GodotClass` on structs."><title>GodotClass in godot::register - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../static.files/rustdoc-916cea96.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="godot" data-themes="" data-resource-suffix="" data-rustdoc-version="1.87.0-nightly (75530e9f7 2025-03-18)" data-channel="nightly" data-search-js="search-e7298875.js" data-settings-js="settings-d72f25bb.js" ><script src="../../static.files/storage-d8ac8691.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../static.files/main-fb8c74a8.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-893ab5e7.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-044be391.svg"></head><body class="rustdoc derive"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button><a class="logo-container" href="../../godot/index.html"><img src="https://raw.githubusercontent.com/godot-rust/assets/master/gdext/ferris.svg" alt=""></a></nav><nav class="sidebar"><div class="sidebar-crate"><a class="logo-container" href="../../godot/index.html"><img src="https://raw.githubusercontent.com/godot-rust/assets/master/gdext/ferris.svg" alt="logo"></a><h2><a href="../../godot/index.html">godot</a><span class="version">0.2.4</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Godot<wbr>Class</a></h2><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#construction" title="Construction">Construction</a></li><li><a href="#inheritance" title="Inheritance">Inheritance</a></li><li><a href="#properties-and-exports" title="Properties and exports">Properties and exports</a><ul><li><a href="#property-registration" title="Property registration">Property registration</a></li><li><a href="#property-exports" title="Property exports">Property exports</a></li></ul></li><li><a href="#further-class-customization" title="Further class customization">Further class customization</a><ul><li><a href="#running-code-in-the-editor" title="Running code in the editor">Running code in the editor</a></li><li><a href="#editor-plugins" title="Editor plugins">Editor plugins</a></li><li><a href="#class-renaming" title="Class renaming">Class renaming</a></li><li><a href="#class-hiding" title="Class hiding">Class hiding</a></li></ul></li><li><a href="#further-field-customization" title="Further field customization">Further field customization</a><ul><li><a href="#fine-grained-inference-hints" title="Fine-grained inference hints">Fine-grained inference hints</a></li></ul></li><li><a href="#documentation" title="Documentation">Documentation</a></li></ul></section><div id="rustdoc-modnav"><h2><a href="index.html">In godot::<wbr>register</a></h2></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="../index.html">godot</a>::<wbr><a href="index.html">register</a></div><h1>Derive Macro <span class="derive">GodotClass</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"></span></div><pre class="rust item-decl"><code>#[derive(GodotClass)]
{
    <span class="comment">// Attributes available to this derive:</span>
    #[class]
    #[base]
    #[hint]
    #[var]
    #[export]
    #[init]
}
</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Derive macro for <a href="../obj/trait.GodotClass.html"><code>GodotClass</code></a> on structs.</p>
<p>You should use this macro; manual implementations of the <code>GodotClass</code> trait are not encouraged.</p>
<p>This is typically used in combination with <a href="attr.godot_api.html"><code>#[godot_api]</code></a>, which can implement custom functions and constants,
as well as override virtual methods.</p>
<p>See also <a href="https://godot-rust.github.io/book/register/classes.html">book chapter <em>Registering classes</em></a>.</p>
<p><strong>Table of contents:</strong></p>
<ul>
<li><a href="#construction">Construction</a></li>
<li><a href="#inheritance">Inheritance</a></li>
<li><a href="#properties-and-exports">Properties and exports</a>
<ul>
<li><a href="#property-registration">Property registration</a></li>
<li><a href="#property-exports">Property exports</a></li>
</ul>
</li>
<li><a href="#further-class-customization">Further class customization</a>
<ul>
<li><a href="#running-code-in-the-editor">Running code in the editor</a></li>
<li><a href="#editor-plugins">Editor plugins</a></li>
<li><a href="#class-renaming">Class renaming</a></li>
<li><a href="#class-hiding">Class hiding</a></li>
</ul>
</li>
<li><a href="#further-field-customization">Further field customization</a>
<ul>
<li><a href="#fine-grained-inference-hints">Fine-grained inference hints</a></li>
</ul>
</li>
</ul>
<h2 id="construction"><a class="doc-anchor" href="#construction">§</a>Construction</h2>
<p>If you don’t override <code>init()</code> manually (within a <code>#[godot_api]</code> block), gdext can generate a default constructor for you.
This constructor is made available to Godot and lets you call <code>MyStruct.new()</code> from GDScript. To enable it, annotate your
struct with <code>#[class(init)]</code>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[derive(GodotClass)]
#[class(init)]
</span><span class="kw">struct </span>MyStruct {
    <span class="comment">// ...
</span>}</code></pre></div>
<p>The generated <code>init</code> function will initialize each struct field (except the field of type <code>Base&lt;T&gt;</code>, if any)
using <code>Default::default()</code>. To assign some other value, annotate the field with <code>#[init(val = ...)]</code>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[derive(GodotClass)]
#[class(init)]
</span><span class="kw">struct </span>MyStruct {
    <span class="attr">#[init(val = <span class="number">42</span>)]
    </span>my_field: i64
}</code></pre></div>
<p>The given value can be any Rust expression that can be evaluated in the scope where you write
the attribute. However, due to limitations in the parser, some complex expressions must be
surrounded by parentheses. This is the case if the expression includes a <code>,</code> that is <em>not</em>
inside any pair of <code>(...)</code>, <code>[...]</code> or <code>{...}</code> (even if it is, for example, inside <code>&lt;...&gt;</code> or
<code>|...|</code>). A contrived example:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[init(val = (HashMap::&lt;i64, i64&gt;::new()))]
</span><span class="comment">//                             ^ parentheses needed due to this comma
</span>my_field: HashMap&lt;i64, i64&gt;,</code></pre></div>
<p>You can also <em>disable</em> construction from GDScript. This needs to be explicit via <code>#[class(no_init)]</code>.
Simply omitting the <code>init</code>/<code>no_init</code> keys and not overriding your own constructor will cause a compile error.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[derive(GodotClass)]
#[class(no_init)]
</span><span class="kw">struct </span>MyStruct {
   <span class="comment">// ...
</span>}</code></pre></div>
<h2 id="inheritance"><a class="doc-anchor" href="#inheritance">§</a>Inheritance</h2>
<p>Unlike C++, Rust doesn’t really have inheritance, but the GDExtension API lets us “inherit”
from a Godot-provided engine class.</p>
<p>By default, classes created with this library inherit from <code>RefCounted</code>, like GDScript.</p>
<p>To specify a different class to inherit from, add <code>#[class(base = Base)]</code> as an annotation on
your <code>struct</code>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[derive(GodotClass)]
#[class(init, base=Node2D)]
</span><span class="kw">struct </span>MyStruct {
    <span class="comment">// ...
</span>}</code></pre></div>
<p>If you need a reference to the base class, you can add a field of type <code>Base&lt;T&gt;</code>. The derive macro will pick this up and wire
your object accordingly. You can access it through <code>self.base()</code> and <code>self.base_mut()</code> methods.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[derive(GodotClass)]
#[class(init, base=Node2D)]
</span><span class="kw">struct </span>MyStruct {
    base: Base&lt;Node2D&gt;,
}</code></pre></div>
<h2 id="properties-and-exports"><a class="doc-anchor" href="#properties-and-exports">§</a>Properties and exports</h2>
<p>See also <a href="https://godot-rust.github.io/book/register/properties.html#registering-properties">book chapter <em>Registering properties</em></a>.</p>
<p>In GDScript, there is a distinction between
<a href="https://docs.godotengine.org/en/stable/tutorials/scripting/gdscript/gdscript_basics.html#properties-setters-and-getters">properties</a>
(fields with a <code>get</code> or <code>set</code> declaration) and
<a href="https://docs.godotengine.org/en/stable/tutorials/scripting/gdscript/gdscript_exports.html">exports</a>
(fields annotated with <code>@export</code>). In the gdext API, these two concepts are represented with <code>#[var]</code> and <code>#[export]</code> attributes respectively,
which in turn are backed by the <a href="../register/property/trait.Var.html"><code>Var</code></a> and <a href="../register/property/trait.Export.html"><code>Export</code></a> traits.</p>
<h3 id="property-registration"><a class="doc-anchor" href="#property-registration">§</a>Property registration</h3>
<p>To create a property, you can use the <code>#[var]</code> annotation:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[derive(GodotClass)]
</span><span class="kw">struct </span>MyStruct {
    <span class="attr">#[var]
    </span>my_field: i64,
}</code></pre></div>
<p>This makes the field accessible in GDScript using <code>my_struct.my_field</code> syntax. Additionally, it
generates a trivial getter and setter named <code>get_my_field</code> and <code>set_my_field</code>, respectively.
These are <code>pub</code> in Rust, since they’re exposed from GDScript anyway.</p>
<p>If you want to implement your own getter and/or setter, write those as a function on your Rust
type, expose it using <code>#[func]</code>, and annotate the field with
<code>#[var(get = ..., set = ...)]</code>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[derive(GodotClass)]
#[class(init)]
</span><span class="kw">struct </span>MyStruct {
    <span class="attr">#[var(get = get_my_field, set = set_my_field)]
    </span>my_field: i64,
}

<span class="attr">#[godot_api]
</span><span class="kw">impl </span>MyStruct {
    <span class="attr">#[func]
    </span><span class="kw">pub fn </span>get_my_field(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; i64 {
        <span class="self">self</span>.my_field
    }

    <span class="attr">#[func]
    </span><span class="kw">pub fn </span>set_my_field(<span class="kw-2">&amp;mut </span><span class="self">self</span>, value: i64) {
        <span class="self">self</span>.my_field = value;
    }
}</code></pre></div>
<p>If you specify only <code>get</code>, no setter is generated, making the field read-only. If you specify
only <code>set</code>, no getter is generated, making the field write-only (rarely useful). To add a
generated getter or setter in these cases anyway, use <code>get</code> or <code>set</code> without a value:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[derive(GodotClass)]
</span><span class="kw">struct </span>MyStruct {
    <span class="comment">// Default getter, custom setter.
    </span><span class="attr">#[var(get, set = set_my_field)]
    </span>my_field: i64,
}

<span class="attr">#[godot_api]
</span><span class="kw">impl </span>MyStruct {
    <span class="attr">#[func]
    </span><span class="kw">pub fn </span>set_my_field(<span class="kw-2">&amp;mut </span><span class="self">self</span>, value: i64) {
        <span class="self">self</span>.my_field = value;
    }
}</code></pre></div>
<h3 id="property-exports"><a class="doc-anchor" href="#property-exports">§</a>Property exports</h3>
<p>For exporting properties to the editor, you can use the <code>#[export]</code> attribute:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[derive(GodotClass)]
</span><span class="kw">struct </span>MyStruct {
    <span class="attr">#[export]
    </span>my_field: i64,
}</code></pre></div>
<p>If you don’t also include a <code>#[var]</code> attribute, then a default one will be generated.
<code>#[export]</code> also supports all of GDScript’s annotations, in a slightly different format. The format is
translated from an annotation by following these four rules:</p>
<ul>
<li><code>@export</code> becomes <code>#[export]</code></li>
<li><code>@export_{name}</code> becomes <code>#[export(name)]</code></li>
<li><code>@export_{name}(elem1, ...)</code> becomes <code>#[export(name = (elem1, ...))]</code></li>
<li><code>@export_{flags/enum}("elem1", "elem2:key2", ...)</code>
becomes
<code>#[export(flags/enum = (elem1, elem2 = key2, ...))]</code></li>
</ul>
<p>As an example of some different export attributes:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[derive(GodotClass)]
</span><span class="kw">struct </span>MyStruct {
    <span class="comment">// @export
    </span><span class="attr">#[export]
    </span>float: f64,
     
    <span class="comment">// @export_range(0.0, 10.0, or_greater)
    </span><span class="attr">#[export(range = (<span class="number">0.0</span>, <span class="number">10.0</span>, or_greater))]
    </span>range_f64: f64,

    <span class="comment">// @export_file
    </span><span class="attr">#[export(file)]
    </span>file: GString,

    <span class="comment">// @export_file("*.gd")
    </span><span class="attr">#[export(file = <span class="string">"*.gd"</span>)]
    </span>gdscript_file: GString,

    <span class="comment">// @export_flags_3d_physics
    </span><span class="attr">#[export(flags_3d_physics)]
    </span>physics: u32,

    <span class="comment">// @export_exp_easing
    </span><span class="attr">#[export(exp_easing)]
    </span>ease: f64,

    <span class="comment">// @export_enum("One", "Two", "Ten:10", "Twelve:12", "Thirteen")
    </span><span class="attr">#[export(<span class="kw">enum </span>= (One, Two, Ten = <span class="number">10</span>, Twelve = <span class="number">12</span>, Thirteen))]
    </span>exported_enum: i64,

    <span class="comment">// @export_flags("A:1", "B:2", "AB:3")
    </span><span class="attr">#[export(flags = (A = <span class="number">1</span>, B = <span class="number">2</span>, AB = <span class="number">3</span>))]
    </span>flags: u32,
}
</code></pre></div>
<p>Most values in expressions like <code>key = value</code>, can be an arbitrary expression that evaluates to the
right value. Meaning you can use constants or variables, as well as any other rust syntax you’d like in
the export attributes.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">const </span>MAX_HEALTH: f64 = <span class="number">100.0</span>;

<span class="attr">#[derive(GodotClass)]
</span><span class="kw">struct </span>MyStruct {
    <span class="attr">#[export(range = (<span class="number">0.0</span>, MAX_HEALTH))]
    </span>health: f64,

    <span class="attr">#[export(flags = (A = <span class="number">0b0001</span>, B = <span class="number">0b0010</span>, C = <span class="number">0b0100</span>, D = <span class="number">0b1000</span>))]
    </span>flags: u32,
}</code></pre></div>
<p>You can specify custom property hints, hint strings, and usage flags in a <code>#[var]</code> attribute using the
<code>hint</code>, <code>hint_string</code>, and <code>usage_flags</code> keys in the attribute. These are constants in the <code>PropertyHint</code>
and <code>PropertyUsageFlags</code> enums, respectively.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[derive(GodotClass)]
</span><span class="kw">struct </span>MyStruct {
    <span class="comment">// Treated as an enum with two values: "One" and "Two"
    // Displayed in the editor
    // Treated as read-only by the editor
    </span><span class="attr">#[var(
        hint = ENUM,
        hint_string = <span class="string">"One,Two"</span>,
        usage_flags = [EDITOR, READ_ONLY]
    </span>)]
    my_field: i64,
}</code></pre></div>
<h2 id="further-class-customization"><a class="doc-anchor" href="#further-class-customization">§</a>Further class customization</h2><h3 id="running-code-in-the-editor"><a class="doc-anchor" href="#running-code-in-the-editor">§</a>Running code in the editor</h3>
<p>If you annotate a class with <code>#[class(tool)]</code>, its lifecycle methods (<code>ready()</code>, <code>process()</code> etc.) will be invoked in the editor. This
is useful for writing custom editor plugins, as opposed to classes running simply in-game.</p>
<p>See <a href="../init/trait.ExtensionLibrary.html#method.editor_run_behavior"><code>ExtensionLibrary::editor_run_behavior()</code></a>
for more information and further customization.</p>
<p>This is very similar to <a href="https://docs.godotengine.org/en/stable/tutorials/plugins/running_code_in_the_editor.html">GDScript’s <code>@tool</code> feature</a>.</p>
<h3 id="editor-plugins"><a class="doc-anchor" href="#editor-plugins">§</a>Editor plugins</h3>
<p>If you annotate a class with <code>#[class(editor_plugin)]</code>, it will be turned into an editor plugin. The
class must then inherit from <code>EditorPlugin</code>, and an instance of that class will be automatically added
to the editor when launched.</p>
<p>See <a href="https://docs.godotengine.org/en/stable/tutorials/plugins/editor/index.html">Godot’s documentation of editor plugins</a>
for more information about editor plugins. But note that you do not need to create and enable the plugin
through Godot’s <code>Create New Plugin</code> menu for it to work, simply annotating the class with <code>editor_plugin</code>
automatically enables it when the library is loaded.</p>
<p>This should usually be combined with <code>#[class(tool)]</code> so that the code you write will actually run in the
editor.</p>
<h3 id="class-renaming"><a class="doc-anchor" href="#class-renaming">§</a>Class renaming</h3>
<p>You may want to have structs with the same name. With Rust, this is allowed using <code>mod</code>. However, in GDScript
there are no modules, namespaces, or any such disambiguation.  Therefore, you need to change the names before they
can get to Godot. You can use the <code>rename</code> key while defining your <code>GodotClass</code> for this.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">mod </span>animal {
    <span class="attr">#[derive(GodotClass)]
    #[class(init, rename=AnimalToad)]
    </span><span class="kw">pub struct </span>Toad {}
}

<span class="kw">mod </span>npc {
    <span class="attr">#[derive(GodotClass)]
    #[class(init, rename=NpcToad)]
    </span><span class="kw">pub struct </span>Toad {}
}</code></pre></div>
<p>These classes will appear in the Godot editor and GDScript as “AnimalToad” or “NpcToad”.</p>
<h3 id="class-hiding"><a class="doc-anchor" href="#class-hiding">§</a>Class hiding</h3>
<p>If you want to register a class with Godot, but not have it show up in the editor then you can use <code>#[class(internal)]</code>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[derive(GodotClass)]
#[class(base=Node, init, internal)]
</span><span class="kw">pub struct </span>Foo {}</code></pre></div>
<p>Even though this class is a <code>Node</code> and it has an init function, it still won’t show up in the editor as a node you can add to a scene
because we have added a <code>hidden</code> key to the class. This will also prevent it from showing up in documentation.</p>
<h2 id="further-field-customization"><a class="doc-anchor" href="#further-field-customization">§</a>Further field customization</h2><h3 id="fine-grained-inference-hints"><a class="doc-anchor" href="#fine-grained-inference-hints">§</a>Fine-grained inference hints</h3>
<p>The derive macro is relatively smart about recognizing <code>Base&lt;T&gt;</code> and <code>OnReady&lt;T&gt;</code> types, and works also if those are qualified.</p>
<p>However, there may be situations where you need to help it out – for example, if you have a type alias for <code>Base&lt;T&gt;</code>, or use an unrelated
<code>my_module::Base&lt;T&gt;</code> with a different meaning.</p>
<p>In this case, you can manually override the behavior with the <code>#[hint]</code> attribute. It takes multiple standalone keys:</p>
<ul>
<li><code>base</code> and <code>no_base</code></li>
<li><code>onready</code> and <code>no_onready</code></li>
</ul>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>godot::classes::Node;

<span class="comment">// There's no reason to do this, but for the sake of example:
</span><span class="kw">type </span>Super&lt;T&gt; = godot::obj::Base&lt;T&gt;;
<span class="kw">type </span>Base&lt;T&gt; = godot::obj::Gd&lt;T&gt;;

<span class="attr">#[derive(godot::register::GodotClass)]
#[class(base=Node)]
</span><span class="kw">struct </span>MyStruct {
   <span class="attr">#[hint(base)]
   </span>base: Super&lt;Node&gt;,

   <span class="attr">#[hint(no_base)]
   </span>unbase: Base&lt;Node&gt;,
}</code></pre></div>
<div class="stab portability">Available on <strong>crate feature <code>register-docs</code></strong> only.</div>
<div class="stab portability">Available on <strong>Godot version <code>4.3+</code></strong> only.</div>
<h2 id="documentation"><a class="doc-anchor" href="#documentation">§</a>Documentation</h2>
<p>You can document your functions, classes, members, and signals with the <code>///</code> doc comment syntax.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[derive(GodotClass)]
</span><span class="doccomment">/// This is an example struct for documentation, inside documentation.
</span><span class="kw">struct </span>DocumentedStruct {
    <span class="doccomment">/// This is a class member.
    /// You can use markdown formatting such as _italics_.
    </span><span class="attr">#[var]
    </span>item: f32,
}

<span class="attr">#[godot_api]
</span><span class="kw">impl </span>DocumentedStruct {
    <span class="doccomment">/// This provides the item, after adding `0.2`.
    </span><span class="attr">#[func]
    </span><span class="kw">pub fn </span>produce_item(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; f32 {
        <span class="self">self</span>.item + <span class="number">0.2
    </span>}
}</code></pre></div>
</div></details></section></div></main></body></html>