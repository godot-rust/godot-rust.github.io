<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Extended documentation"><title>godot::__docs - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2"href="../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../static.files/rustdoc-ca0dd0c4.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="godot" data-themes="" data-resource-suffix="" data-rustdoc-version="1.93.0-nightly (b84478a1c 2025-11-30)" data-channel="nightly" data-search-js="search-9e2438ea.js" data-stringdex-js="stringdex-a3946164.js" data-settings-js="settings-c38705f0.js" ><script src="../../static.files/storage-e2aeef58.js"></script><script defer src="../sidebar-items.js"></script><script defer src="../../static.files/main-a410ff4d.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-263c88ec.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-eab170b8.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-044be391.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><rustdoc-topbar><h2><a href="#">Module __docs</a></h2></rustdoc-topbar><nav class="sidebar"><div class="sidebar-crate"><a class="logo-container" href="../../godot/index.html"><img src="https://raw.githubusercontent.com/godot-rust/assets/master/gdext/ferris.svg" alt="logo"></a><h2><a href="../../godot/index.html">godot</a><span class="version">Pull Request #1424</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Module __docs</a></h2><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#extended-documentation" title="Extended documentation">Extended documentation</a><ul><li><a href="#type-categories" title="Type categories">Type categories</a></li><li><a href="#ergonomics-and-panics" title="Ergonomics and panics">Ergonomics and panics</a></li><li><a href="#thread-safety" title="Thread safety">Thread safety</a></li><li><a href="#builtin-api-design" title="Builtin API Design">Builtin API Design</a></li></ul></li></ul></section><div id="rustdoc-modnav"><h2 class="in-crate"><a href="../index.html">In crate godot</a></h2></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="../index.html">godot</a></div><h1>Module <span>__docs</span>&nbsp;<button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../src/godot/__docs.rs.html#8-242">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><h2 id="extended-documentation"><a class="doc-anchor" href="#extended-documentation">§</a>Extended documentation</h2>
<p>This highlights a few concepts in the public API of the <code>godot</code> crate. They complement information
available on the main crate documentation page and the book.</p>
<h3 id="type-categories"><a class="doc-anchor" href="#type-categories">§</a>Type categories</h3>
<p>Godot is written in C++, which doesn’t have the same strict guarantees about safety and
mutability that Rust does. As a result, not everything in this crate will look and feel
entirely “rusty”. See also <a href="https://godot-rust.github.io/book/contribute/philosophy.html">Philosophy</a>.</p>
<p>Traits such as <code>Clone</code>, <code>PartialEq</code> or <code>PartialOrd</code> are designed to mirror Godot semantics,
except in cases where Rust is stricter (e.g. float ordering). Cloning a type results in the
same observable behavior as assignment or parameter-passing of a GDScript variable.</p>
<p>We distinguish four different kinds of types:</p>
<ol>
<li>
<p><strong>Value types</strong>: <code>i64</code>, <code>f64</code>, and mathematical types like
<a href="../prelude/struct.Vector2.html" title="struct godot::prelude::Vector2"><code>Vector2</code></a> and <a href="../prelude/struct.Color.html" title="struct godot::prelude::Color"><code>Color</code></a>.</p>
<p>These are the simplest to understand and to work with. They implement <code>Clone</code> and often
<code>Copy</code> as well. They are implemented with the same memory layout as their counterparts in
Godot itself, and typically have public fields. <br><br></p>
</li>
<li>
<p><strong>Copy-on-write types</strong>: <a href="../prelude/struct.GString.html" title="struct godot::prelude::GString"><code>GString</code></a>,
<a href="../prelude/struct.StringName.html" title="struct godot::prelude::StringName"><code>StringName</code></a>, and <a href="../prelude/struct.PackedArray.html" title="struct godot::prelude::PackedArray"><code>PackedArray</code></a> types.</p>
<p>These mostly act like value types, similar to Rust’s own <code>Vec</code>. You can <code>Clone</code> them to get
a full copy of the entire object, as you would expect.</p>
<p>Under the hood in Godot, these types are implemented with copy-on-write, so that data can be
shared until one of the copies needs to be modified. However, this performance optimization
is entirely hidden from the API and you don’t normally need to worry about it. <br><br></p>
</li>
<li>
<p><strong>Reference-counted types</strong>: <a href="../prelude/struct.Array.html" title="struct godot::prelude::Array"><code>Array</code></a>,
<a href="../prelude/struct.Dictionary.html" title="struct godot::prelude::Dictionary"><code>Dictionary</code></a>, and <a href="../prelude/struct.Gd.html" title="struct godot::prelude::Gd"><code>Gd&lt;T&gt;</code></a> where <code>T</code> inherits
from <a href="../prelude/struct.RefCounted.html" title="struct godot::prelude::RefCounted"><code>RefCounted</code></a>.</p>
<p>These types may share their underlying data between multiple instances: changes to one
instance are visible in another. They are conceptually similar to <code>Rc&lt;RefCell&lt;...&gt;&gt;</code>.</p>
<p>Since there is no way to prevent or even detect this sharing from Rust, you need to be more
careful when using such types. For example, when iterating over an <code>Array</code>, make sure that
it isn’t being modified at the same time through another reference.</p>
<p><code>Clone::clone()</code> on these types creates a new reference to the same instance, while
type-specific methods such as <a href="../prelude/struct.Array.html#method.duplicate_deep" title="method godot::prelude::Array::duplicate_deep"><code>Array::duplicate_deep()</code></a>
can be used to make actual copies. <br><br></p>
</li>
<li>
<p><strong>Manually managed types</strong>: <a href="../prelude/struct.Gd.html" title="struct godot::prelude::Gd"><code>Gd&lt;T&gt;</code></a> where <code>T</code> inherits from
<a href="../prelude/struct.Object.html" title="struct godot::prelude::Object"><code>Object</code></a> but not from <a href="../prelude/struct.RefCounted.html" title="struct godot::prelude::RefCounted"><code>RefCounted</code></a>;
most notably, this includes all <code>Node</code> classes.</p>
<p>These also share data, but do not use reference counting to manage their memory. Instead,
you must either hand over ownership to Godot (e.g. by adding a node to the scene tree) or
free them manually using <a href="../prelude/struct.Gd.html#method.free" title="method godot::prelude::Gd::free"><code>Gd::free()</code></a>. <br><br></p>
</li>
</ol>
<h3 id="ergonomics-and-panics"><a class="doc-anchor" href="#ergonomics-and-panics">§</a>Ergonomics and panics</h3>
<p>gdext is designed with usage ergonomics in mind, making it viable for fast prototyping.
Part of this design means that users should not constantly be forced to write code such as
<code>obj.cast::&lt;T&gt;().unwrap()</code>. Instead, they can just write <code>obj.cast::&lt;T&gt;()</code>, which may panic at runtime.</p>
<p>This approach has several advantages:</p>
<ul>
<li>The code is more concise and less cluttered.</li>
<li>Methods like <code>cast()</code> provide very sophisticated panic messages when they fail (e.g. involved
classes), immediately giving you the necessary context for debugging. This is certainly
preferable over a generic <code>unwrap()</code>, and in most cases also over a <code>expect("literal")</code>.</li>
<li>Usually, such methods panicking indicate bugs in the application. For example, you have a static
scene tree, and you <em>know</em> that a node of certain type and name exists. <code>get_node_as::&lt;T&gt;("name")</code>
thus <em>must</em> succeed, or your mental concept is wrong. In other words, there is not much you can
do at runtime to recover from such errors anyway; the code needs to be fixed.</li>
</ul>
<p>Now, there are of course cases where you <em>do</em> want to check certain assumptions dynamically.
Imagine a scene tree that is constructed at runtime, e.g. in a game editor.
This is why the library provides “overloads” for most of these methods that return <code>Option</code> or <code>Result</code>.
Such methods have more verbose names and highlight the attempt, e.g. <code>try_cast()</code>.</p>
<p>To help you identify panicking methods, we use the symbol “⚠️” at the beginning of the documentation;
this should also appear immediately in the auto-completion of your IDE. Note that this warning sign is
not used as a general panic indicator, but particularly for methods which have a <code>Option</code>/<code>Result</code>-based
overload. If you want to know whether and how a method can panic, check if its documentation has a
<em>Panics</em> section.
<br><br></p>
<h3 id="thread-safety"><a class="doc-anchor" href="#thread-safety">§</a>Thread safety</h3>
<p><a href="https://docs.godotengine.org/en/latest/tutorials/performance/thread_safe_apis.html">Godot’s own thread safety
rules</a>
apply. Types in this crate implement (or don’t implement) <code>Send</code> and <code>Sync</code> wherever
appropriate, but the Rust compiler cannot check what happens to an object through C++ or
GDScript.</p>
<p>As a rule of thumb, if you must use threading, prefer to use <a href="https://doc.rust-lang.org/std/thread">Rust threads</a>
over Godot threads.</p>
<p>The Cargo feature <code>experimental-threads</code> provides experimental support for multithreading. The underlying safety
rules are still being worked out, as such you may encounter unsoundness and an unstable API.</p>
<h3 id="builtin-api-design"><a class="doc-anchor" href="#builtin-api-design">§</a>Builtin API Design</h3>
<p>See also <a href="../builtin/index.html" title="mod godot::builtin"><code>godot::builtin</code></a> module documentation.</p>
<p>Our goal is to strive for a middle ground between idiomatic Rust and existing Godot APIs, achieving a decent balance between ergonomics,
correctness and performance. We leverage Rust’s type system (such as <code>Option&lt;T&gt;</code> or <code>enum</code>) where it helps expressivity.</p>
<p>We have been using a few guiding principles. Those apply to builtins in particular, but some are relevant in other modules, too.</p>
<h4 id="1-copy-for-value-types"><a class="doc-anchor" href="#1-copy-for-value-types">§</a>1. <code>Copy</code> for value types</h4>
<p><em>Value types</em> are types with public fields and no hidden state. This includes all geometric types, colors and RIDs.</p>
<p>All value types implement the <code>Copy</code> trait and thus have no custom <code>Drop</code> impl.</p>
<h4 id="2-by-value-self-vs-by-reference-self-receivers"><a class="doc-anchor" href="#2-by-value-self-vs-by-reference-self-receivers">§</a>2. By-value (<code>self</code>) vs. by-reference (<code>&amp;self</code>) receivers</h4>
<p>Most <code>Copy</code> builtins use by-value receivers. The exception are matrix-like types (e.g., <code>Basis</code>, <code>Transform2D</code>, <code>Transform3D</code>, <code>Projection</code>),
whose methods operate on <code>&amp;self</code> instead. This is close to how the underlying <code>glam</code> library handles it.</p>
<h4 id="3-default-trait-only-when-the-default-value-is-common-and-useful"><a class="doc-anchor" href="#3-default-trait-only-when-the-default-value-is-common-and-useful">§</a>3. <code>Default</code> trait only when the default value is common and useful</h4>
<p><code>Default</code> is deliberately not implemented for every type. Rationale:</p>
<ul>
<li>For some types, the default representation (as per Godot) does not constitute a useful value. This goes against Rust’s <a href="https://doc.rust-lang.org/nightly/core/default/trait.Default.html" title="trait core::default::Default"><code>Default</code></a> docs,
which explicitly mention “A trait for giving a type a <em>useful</em> default value”. For example, <code>Plane()</code> in GDScript creates a degenerate
plane which cannot participate in geometric operations.</li>
<li>Not providing <code>Default</code> makes users double-check if the value they want is indeed what they intended. While it seems convenient, not
having implicit default or “null” values is a design choice of Rust, avoiding the Billion Dollar Mistake. In many situations, <code>Option</code> or
<a href="../prelude/struct.OnReady.html" title="struct godot::prelude::OnReady"><code>OnReady</code></a> is a better alternative.</li>
<li>For cases where the Godot default is truly desired, we provide an <code>invalid()</code> constructor, e.g. <code>Callable::invalid()</code> or <code>Plane::invalid()</code>.
This makes it explicit that you’re constructing a value that first has to be modified before becoming useful. When used in class fields,
<code>#[init(val = ...)]</code> can help you initialize such values.</li>
<li>Outside builtins, we do not implement <code>Gd::default()</code> for manually managed types, as this makes it very easy to overlook initialization
(e.g. in <code>#[derive(Default)]</code>) and leak memory. A <code>Gd::new_alloc()</code> is very explicit.</li>
</ul>
<h4 id="4-prefer-explicit-conversions-over-from-trait"><a class="doc-anchor" href="#4-prefer-explicit-conversions-over-from-trait">§</a>4. Prefer explicit conversions over <code>From</code> trait</h4>
<p><code>From</code> is quite popular in Rust, but unlike traits such as <code>Debug</code>, the convenience of <code>From</code> can come at a cost. Like every feature, adding
an <code>impl From</code> needs to be justified – not the other way around: there doesn’t need to be a particular reason why it’s <em>not</em> added. But
there are in fact some trade-offs to consider:</p>
<ol>
<li><code>From</code> next to named conversion methods/constructors adds another way to do things. While it’s sometimes good to have choice, multiple
ways to achieve the same has downsides: users wonder if a subtle difference exists, or if all options are in fact identical.
It’s unclear which one is the “preferred” option. Recognizing other people’s code becomes harder, because there tend to be dialects.</li>
<li>It’s often a purely stylistic choice, without functional benefits. Someone may want to write <code>(1, 2).into()</code> instead of
<code>Vector2i::new(1, 2)</code>. This is not strong enough of a reason – if brevity is of concern, a function <code>vec2i(1, 2)</code> does the job better.</li>
<li><code>From</code> is less explicit than a named conversion function. If you see <code>string.to_variant()</code> or <code>color.to_hsv()</code>, you immediately
know the target type. <code>string.into()</code> and <code>color.into()</code> lose that aspect. Even with <code>(1, 2).into()</code>, you’d first have to check whether
<code>From</code> is only converting the tuple, or if it <em>also</em> provides an <code>i32</code>-to-<code>f32</code> cast, thus resulting in <code>Vector2</code> instead of <code>Vector2i</code>.
This problem doesn’t exist with named constructor functions.</li>
<li>The <code>From</code> trait doesn’t play nicely with type inference. If you write <code>let v = string.to_variant()</code>, rustc can infer the type of <code>v</code>
based on the right-hand expression alone. With <code>.into()</code>, you need follow-up code to determine the type, which may or may not work.
Temporarily commenting out such non-local code breaks the declaration line, too. To make matters worse, turbofish <code>.into::&lt;Type&gt;()</code> isn’t
possible either.</li>
<li>Rust itself <a href="https://doc.rust-lang.org/std/convert/trait.From.html#when-to-implement-from">requires</a> that <code>From</code> conversions are
infallible, lossless, value-preserving and obvious. This rules out a lot of scenarios such as <code>DynGd::to_gd()</code> (which only maintains
the class part, not trait) or <code>Color::try_to_hsv()</code> (which is fallible and lossy).</li>
</ol>
<p>One main reason to support <code>From</code> is to allow generic programming, in particular <code>impl Into&lt;T&gt;</code> parameters. This is also the reason
why the string types have historically implemented the trait. But this became less relevant with the advent of
<a href="../meta/trait.AsArg.html" title="trait godot::meta::AsArg"><code>AsArg&lt;T&gt;</code></a> taking that role, and thus may change in the future.</p>
<h4 id="5-option-for-fallible-operations"><a class="doc-anchor" href="#5-option-for-fallible-operations">§</a>5. <code>Option</code> for fallible operations</h4>
<p>GDScript often uses degenerate types and custom null states to express that an operation isn’t successful. This isn’t always consistent:</p>
<ul>
<li><a href="https://docs.godotengine.org/en/stable/classes/class_rect2.html#class-rect2-method-intersection"><code>Rect2::intersection()</code></a> returns an empty rectangle (i.e. you need to check its size).</li>
<li><a href="https://docs.godotengine.org/en/stable/classes/class_plane.html#class-plane-method-intersects-ray"><code>Plane::intersects_ray()</code></a> returns a <code>Variant</code> which is NIL in case of no intersection. While this is a better way to deal with it,
it’s not immediately obvious that the result is a point (<code>Vector2</code>), and comes with extra marshaling overhead.</li>
</ul>
<p>Rust uses <code>Option</code> in such cases, making the error state explicit and preventing that the result is accidentally interpreted as valid.</p>
<h4 id="6-public-fields-and-soft-invariants"><a class="doc-anchor" href="#6-public-fields-and-soft-invariants">§</a>6. Public fields and soft invariants</h4>
<p>Some geometric types are subject to “soft invariants”. These invariants are not enforced at all times but are essential for certain
operations. For example, bounding boxes must have non-negative volume for operations like intersection or containment checks. Planes
must have a non-zero normal vector.</p>
<p>We cannot make them hard invariants (no invalid value may ever exist), because that would disallow the convenient public fields, and
it would also mean every value coming over the FFI boundary (e.g. an <code>#[export]</code> field set in UI) would constantly need to be validated
and reset to a different “sane” value.</p>
<p>For <strong>geometric operations</strong>, Godot often doesn’t specify the behavior if values are degenerate, which can propagate bugs that then lead
to follow-up problems. godot-rust instead provides best-effort validations <em>during an operation</em>, which cause panics if such invalid states
are detected (at least in Debug mode). Consult the docs of a concrete type to see its guarantees.</p>
<h4 id="7-riir-for-some-but-not-all-builtins"><a class="doc-anchor" href="#7-riir-for-some-but-not-all-builtins">§</a>7. RIIR for some, but not all builtins</h4>
<p>Builtins use varying degrees of Rust vs. engine code for their implementations. This may change over time and is generally an implementation
detail.</p>
<ul>
<li>100% Rust, often supported by the <code>glam</code> library:
<ul>
<li>all vector types (<code>Vector2</code>, <code>Vector2i</code>, <code>Vector3</code>, <code>Vector3i</code>, <code>Vector4</code>, <code>Vector4i</code>)</li>
<li>all bounding boxes (<code>Rect2</code>, <code>Rect2i</code>, <code>Aabb</code>)</li>
<li>2D/3D matrices (<code>Basis</code>, <code>Transform2D</code>, <code>Transform3D</code>)</li>
<li><code>Plane</code></li>
<li><code>Rid</code> (just an integer)</li>
</ul>
</li>
<li>Partial Rust: <code>Color</code>, <code>Quaternion</code>, <code>Projection</code></li>
<li>Only Godot FFI: all others (containers, strings, callables, variant, …)</li>
</ul>
<p>The rationale here is that operations which are absolutely ubiquitous in game development, such as vector/matrix operations, benefit
a lot from being directly implemented in Rust. This avoids FFI calls, which aren’t necessarily slow, but remove a lot of optimization
potential for rustc/LLVM.</p>
<p>Other types, that are used less in bulk and less often in performance-critical paths (e.g. <code>Projection</code>), partially fall back to Godot APIs.
Some operations are reasonably complex to implement in Rust, and we’re not a math library, nor do we want to depend on one besides <code>glam</code>.
An ever-increasing maintenance burden for geometry re-implementations is also detrimental.</p>
<p>TLDR: it’s a trade-off between performance, maintenance effort and correctness – the current combination of <code>glam</code> and Godot seems to be a
relatively well-working sweet spot.</p>
<h4 id="8-glam-types-are-not-exposed-in-public-api"><a class="doc-anchor" href="#8-glam-types-are-not-exposed-in-public-api">§</a>8. <code>glam</code> types are not exposed in public API</h4>
<p>While Godot and <code>glam</code> share common operations, there are also lots of differences and Godot specific APIs.
As a result, godot-rust defines its own vector and matrix types, making <code>glam</code> an implementation details.</p>
<p>Alternatives considered:</p>
<ol>
<li>
<p>Re-export types of an existing vector algebra crate (like <code>glam</code>).
The <code>gdnative</code> crate started out this way, using types from <code>euclid</code>, but <a href="https://github.com/godot-rust/gdnative/issues/594#issue-705061720">became impractical</a>.
Even with extension traits, there would be lots of compromises, where existing and Godot APIs differ slightly.</p>
<p>Furthermore, it would create a strong dependency on a volatile API outside our control. <code>glam</code> had 9 SemVer-breaking versions over the
timespan of two years (2022-2024). While it’s often easy to migrate and the changes notably improve the library, this would mean that any
breaking change would also become breaking for godot-rust, requiring a SemVer bump. By abstracting this, we can have our own timeline.</p>
</li>
<li>
<p>We could opaquely wrap types, i.e. <code>Vector2</code> would contain a private <code>glam::Vec2</code>. This would prevent direct field access, which is
<em>extremely</em> inconvenient for vectors. And it would still require us to redefine the front-end of the entire API.</p>
</li>
</ol>
<p>Eventually, we might add support for <a href="https://crates.io/crates/mint"><code>mint</code></a> to allow conversions to other linear algebra libraries in the
ecosystem. (Note that <code>mint</code> intentionally offers no math operations, see e.g. <a href="https://github.com/kvark/mint/issues/75">mint#75</a>).</p>
</div></details></section></div></main></body></html>